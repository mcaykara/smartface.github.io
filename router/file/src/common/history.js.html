<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/common/history.js | Smartface NativeRouter</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Smartface NativeRouter"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Smartface NativeRouter"><meta property="twitter:description" content="Smartface NativeRouter"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/smartface/router"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-HistoryListener">HistoryListener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-NavigationControllerTransformEvent">NavigationControllerTransformEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteBuildHandler">RouteBuildHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteLocation">RouteLocation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteMatch">RouteMatch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteParams">RouteParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteState">RouteState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouterBlockHandler">RouterBlockHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.BottomTabBarItem">BottomTabBarItem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.BottomTabBarController">BottomTabbarController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.NavigationController">NavigationController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.Page">Page</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#native">native</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/BottomTabBarRouter.js~BottomTabBarRouter.html">BottomTabBarRouter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/NativeRouter.js~NativeRouter.html">NativeRouter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/NativeRouterBase.js~NativeRouterBase.html">NativeRouterBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/NativeStackRouter.js~NativeStackRouter.html">NativeStackRouter</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#router">router</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/router/Route.js~Route.html">Route</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/router/Route.js~RoutePath.html">RoutePath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/router/Router.js~Router.html">Router</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/common/history.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// https://github.com/ReactTraining/history
&quot;use strict&quot;;

const resolvePathname = require(&quot;resolve-pathname/umd/resolve-pathname&quot;);

const warning = require(&quot;./warning&quot;);
const createPath = location =&gt; {
  const { pathname, search, hash } = location;

  let path = pathname || &quot;/&quot;;

  if (search &amp;&amp; search !== &quot;?&quot;)
    path += search.charAt(0) === &quot;?&quot; ? search : `?${search}`;

  if (hash &amp;&amp; hash !== &quot;#&quot;) path += hash.charAt(0) === &quot;#&quot; ? hash : `#${hash}`;

  return path;
};

const parsePath = path =&gt; {
  let pathname = path || &quot;/&quot;;
  let search = &quot;&quot;;
  let hash = &quot;&quot;;

  const hashIndex = pathname.indexOf(&quot;#&quot;);
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  const searchIndex = pathname.indexOf(&quot;?&quot;);
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname,
    search: search === &quot;?&quot; ? &quot;&quot; : search,
    hash: hash === &quot;#&quot; ? &quot;&quot; : hash
  };
};

const createLocation = (path, state, key, currentLocation) =&gt; {
  let location;
  if (typeof path === &quot;string&quot;) {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = Object.assign({}, path);

    if (location.pathname === undefined) location.pathname = &quot;&quot;;

    if (location.search) {
      if (location.search.charAt(0) !== &quot;?&quot;)
        location.search = &quot;?&quot; + location.search;
    } else {
      location.search = &quot;&quot;;
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== &quot;#&quot;) location.hash = &quot;#&quot; + location.hash;
    } else {
      location.hash = &quot;&quot;;
    }

    if (state !== undefined &amp;&amp; location.state === undefined)
      location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError(
        &apos;Pathname &quot;&apos; +
          location.pathname +
          &apos;&quot; could not be decoded. &apos; +
          &quot;This is likely caused by an invalid percent-encoding.&quot;
      );
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== &quot;/&quot;) {
      location.pathname = resolvePathname(
        location.pathname,
        currentLocation.pathname
      );
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = &quot;/&quot;;
    }
  }

  return location;
};

const createTransitionManager = require(&quot;./createTransitionManager&quot;);

const clamp = (n, lowerBound, upperBound) =&gt;
  Math.min(Math.max(n, lowerBound), upperBound);

/**
 * Creates a history object that stores locations in memory.
 * @ignore
 */
const createMemoryHistory = (props = {}) =&gt; {
  const {
    getUserConfirmation,
    initialEntries = [&quot;/&quot;],
    initialIndex = 0,
    keyLength = 6
  } = props;

  const transitionManager = createTransitionManager();

  const setState = nextState =&gt; {
    Object.assign(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  const createKey = () =&gt;
    Math.random()
      .toString(36)
      .substr(2, keyLength);

  const index = clamp(initialIndex, 0, initialEntries.length - 1);
  const entries = initialEntries.map(
    entry =&gt;
      typeof entry === &quot;string&quot;
        ? createLocation(entry, undefined, createKey())
        : createLocation(entry, undefined, entry.key || createKey())
  );

  // Public interface

  const createHref = createPath;

  const push = (path, state) =&gt; {
    warning(
      !(
        typeof path === &quot;object&quot; &amp;&amp;
        path.state !== undefined &amp;&amp;
        state !== undefined
      ),
      &quot;You should avoid providing a 2nd state argument to push when the 1st &quot; +
        &quot;argument is a location-like object that already has state; it is ignored&quot;
    );

    const action = &quot;PUSH&quot;;
    const location = createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(
      location,
      action,
      getUserConfirmation,
      ok =&gt; {
        if (!ok) return;

        const prevIndex = history.index;
        const nextIndex = prevIndex + 1;

        const nextEntries = history.entries.slice(0);
        if (nextEntries.length &gt; nextIndex) {
          nextEntries.splice(
            nextIndex,
            nextEntries.length - nextIndex,
            location
          );
        } else {
          nextEntries.push(location);
        }

        setState({
          action,
          location,
          index: nextIndex,
          entries: nextEntries
        });
      }
    );
  };

  const replace = (path, state) =&gt; {
    warning(
      !(
        typeof path === &quot;object&quot; &amp;&amp;
        path.state !== undefined &amp;&amp;
        state !== undefined
      ),
      &quot;You should avoid providing a 2nd state argument to replace when the 1st &quot; +
        &quot;argument is a location-like object that already has state; it is ignored&quot;
    );

    const action = &quot;REPLACE&quot;;
    const location = createLocation(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(
      location,
      action,
      getUserConfirmation,
      ok =&gt; {
        if (!ok) return;

        history.entries[history.index] = location;

        setState({ action, location });
      }
    );
  };

  const go = n =&gt; {
    const nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    const action = &quot;POP&quot;;
    const location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(
      location,
      action,
      getUserConfirmation,
      ok =&gt; {
        if (ok) {
          setState({
            action,
            location,
            index: nextIndex
          });
        } else {
          // Mimic the behavior of DOM histories by
          // causing a render after a cancelled POP.
          setState();
        }
      }
    );
  };

  const goBack = () =&gt; go(-1);

  const goForward = () =&gt; go(1);
  const clear = () =&gt; {
    history.index = 0;
    history.entries = [];
    history.length = 0;
  };

  const rollback = () =&gt; {
    history.entries.pop();
    history.length = history.length;
    history.index--;
  };

  const silencePush = (path, state) =&gt; {
    const action = &quot;PUSH&quot;;
    const location = createLocation(path, state, createKey(), history.location);

    history.entries.push(location);
    history.length = history.length;
    history.index++;
  };

  const canGo = n =&gt; {
    const nextIndex = history.index + n;

    return nextIndex &gt;= 0 &amp;&amp; nextIndex &lt; history.entries.length;
  };

  const block = (prompt = false) =&gt; transitionManager.setPrompt(prompt);

  const listen = listener =&gt; transitionManager.appendListener(listener);

  const history = {
    length: entries.length,
    action: &quot;POP&quot;,
    location: entries[index],
    index,
    entries,
    createHref,
    push,
    silencePush,
    replace,
    rollback,
    go,
    clear,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };

  return history;
};

module.exports = createMemoryHistory;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
