<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/router/Router.js | Smartface NativeRouter</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Smartface NativeRouter"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Smartface NativeRouter"><meta property="twitter:description" content="Smartface NativeRouter"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/smartface/router"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-History">History</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-HistoryListener">HistoryListener</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteBuildHandler">RouteBuildHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteShouldMatchHandler">RouteShouldMatchHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouterBlockHandler">RouterBlockHandler</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.BottomTabBarController">BottomTabbarController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.Color">Color</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.Image">Image</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.NavigationController">NavigationController</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.Page">Page</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="http://docs.smartface.io/#!/api/UI.TabBarItem">TabBarItem</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#common">common</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createHistory">createHistory</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#native">native</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/AndroidRenderer.js~AndroidRenderer.html">AndroidRenderer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/BottomTabBarRouter.js~BottomTabBarRouter.html">BottomTabBarRouter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/IOSRenderer.js~IOSRenderer.html">IOSRenderer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/NativeRouter.js~NativeRouter.html">NativeRouter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/NativeRouterBase.js~NativeRouterBase.html">NativeRouterBase</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/NativeStackRouter.js~NativeStackRouter.html">NativeStackRouter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/native/Renderer.js~Renderer.html">Renderer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createTabBarItem">createTabBarItem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-BottomTabBarItem">BottomTabBarItem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-BottomTabBarRouterParams">BottomTabBarRouterParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-HeaderBarParams">HeaderBarParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-NativeStackRouterParams">NativeStackRouterParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-NavigationControllerTransformEvent">NavigationControllerTransformEvent</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#router">router</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/router/Route.js~Route.html">Route</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/router/Route.js~RoutePath.html">RoutePath</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/router/Router.js~Router.html">Router</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteLocation">RouteLocation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteMatch">RouteMatch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteParams">RouteParams</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouteState">RouteState</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RouterParams">RouterParams</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/router/Router.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&quot;use strict&quot;;

const Route = require(&quot;./Route&quot;);
const matchRoutes = require(&quot;../common/matchRoutes&quot;);
const createHistory = require(&quot;../common/createHistory&quot;);
const createStore = require(&quot;./routeStore&quot;);
const funcorVal = require(&quot;../utils/funcorVal&quot;);
let tasks = [];

let historyController;

let _lastRoute;
const listeners = new Set();
const history = [];
let store;

const dispatch = (location, action) =&gt; {
  history.push([location.pathnamme, action]);
  listeners.forEach(listener =&gt; listener(location, action));
  action === &quot;PUSH&quot;
    ? historyController.pushLocation(location) // TODO: not share loaction instance
    : historyController.goBack();
};

function handleRouteUrl(router, url, routeData, action) {
  if (url === router._state.prevUrl) return;

  router._historyController.preventDefault();
  switch (action) {
    case &quot;PUSH&quot;:
      router._historyController.push(url, routeData);
      break;
    case &quot;POP&quot;:
      router._historyController.goBack();
      break;
  }
}

/**
 * @typedef {object} RouterParams
 * @property {!string} [path]  Routing path
 * @property {!Array&lt;Route&gt;} [routes=[]] Child routes
 * @property {?boolean} [exact=false] If it&apos;s only exact match or not
 * @property {?boolean} [isRoot=false] If it&apos;s root router
 * @property {?(string|null)} to Redirection path
 * @property {?boolean} [strict=false] strict
 * @property {?boolean} [sensitive=false] sensitive Path is case sensitive or not
 * @property {?function(router: Router, prevUrl: string, currentUrl: stirng, action: string)} routerDidEnter Handles the Router is actived.
 * @property {?function(router: Router, prevUrl: string, action: string)} routerDidExit Handles the Router is deactived.
 * @property {number} homeRoute Home route index of the router&apos;s children. If it pushes first when routed to router&apos;s.
 */

/**
 * Router Base
 *
 * @description
 * Router implementation creates a thin layer between view and application layers
 * to handle view changes and to create loosely coupled and resuable routing logic.
 *
 * @class
 *
 * @example
 *  const router = Router.of({
 *   path: &quot;/&quot;,
 *   to: &quot;/pages/page2&quot;,
 *   isRoot: true,
 *   routes: [
 *       Route.of({
 *           path: &quot;/pages/page2&quot;,
 *           build: (match, state) =&gt; {
 *               let Page2 = require(&quot;pages/page2&quot;);
 *               return new Page2();
 *           }
 *       }),
 *       StackRouter.of({
 *           path: &quot;/stack&quot;,
 *           to: &quot;/stack/path1&quot;,
 *           headerBarParams: () =&gt; { ios: { translucent: true } },
 *           routes: [
 *               Route.of({
 *                   path: &quot;/stack/path1&quot;,
 *                   build: (match, state, router) =&gt; new Page1(state.data, router)
 *               }),
 *               Route.of({
 *                   path: &quot;/stack/path2&quot;,
 *                   routeShouldMatch: (route, nextState) =&gt; {
 *                       console.log(&apos;routeShouldMatch&apos;);
 *                       if (!nextState.routeData.applied) {
 *                           // blocks route changing
 *                           return false;
 *                       }
 *                       return false;
 *                   },
 *                   build: (router, route) =&gt; {
 *                       const { routeData, view } = route.getState();
 *                       return new Page2(routeData, router);
 *                   }
 *               })
 *           ]
 *       }),
 *       BottomTabBarRouter.of({
 *           path: &quot;/bottom&quot;,
 *           to: &quot;/bottom/stack2/path1&quot;,
 *           tabbarParams: () =&gt; ({
 *               ios: { translucent: false },
 *               itemColor: Color.RED,
 *               unselectedItemColor: Color.YELLOW,
 *               backgroundColor: Color.BLUE
 *           }),
 *           items: () =&gt; [{ title: &quot;page1&quot; }, { title: &quot;page2&quot; }, { title: &quot;page3&quot; }],
 *           routes: [
 *               StackRouter.of({
 *                   path: &quot;/bottom/stack&quot;,
 *                   to: &quot;/bottom/stack/path1&quot;,
 *                   headerBarParams: () =&gt; { ios: { translucent: false } },
 *                   routes: [
 *                       Route.of({
 *                           path: &quot;/bottom/stack/path1&quot;,
 *                           build: (router, route) =&gt; new Page1(route.getState().routeData, router, &quot;/stack/path2&quot;)
 *                       }),
 *                       Route.of({
 *                           path: &quot;/bottom/stack/path2&quot;,
 *                           build: (router, route) =&gt; {
 *                               const { routeData, view } = route.getState();
 *
 *                               return new Page2(routeData, router, &quot;/bottom/stack2/path1&quot;);
 *                           }
 *                       })
 *                   ]
 *               }),
 *               StackRouter.of({
 *                   path: &quot;/bottom/stack2&quot;,
 *                   to: &quot;/bottom/stack2/path1&quot;,
 *                   headerBarParams: () =&gt; { ios: { translucent: false } },
 *                   routes: [
 *                       Route.of({
 *                           path: &quot;/bottom/stack2/path1&quot;,
 *                           build: (router, route) =&gt; new Page1(route.getState().routeData, router, &quot;/bottom/stack/path2&quot;)
 *                       }),
 *                       Route.of({
 *                           path: &quot;/bottom/stack2/path2&quot;,
 *                           build: (router, route) =&gt; {
 *                               return new Page2(route.getState().routeData, router);
 *                           }
 *                       })
 *                   ]
 *               })
 *           ]
 *       })
 *   ]
 * });
 *
 * @example
 * // Homeroute setting
 *
 * ...
 *      StackRouter.of({
 *           path: &quot;/stack&quot;,
 *           to: &quot;/stack/path1&quot;,
 *           homeRoute: 0, // it&apos;s first push if target is path diffrent.
 *           headerBarParams: () =&gt; { ios: { translucent: true } },
 *           routes: [
 *               Route.of({
 *                   path: &quot;/stack/path1&quot;,
 *                   build: (match, state, router) =&gt; new Page1(state.data, router)
 *               }),
 *               Route.of({
 *                   path: &quot;/stack/path2&quot;,
 *                   routeShouldMatch: (route, nextState) =&gt; {
 *                       console.log(&apos;routeShouldMatch&apos;);
 *                       if (!nextState.routeData.applied) {
 *                           // blocks route changing
 *                           return false;
 *                       }
 *                       return false;
 *                   },
 *                   build: (router, route) =&gt; {
 *                       const { routeData, view } = route.getState();
 *                       return new Page2(routeData, router);
 *                   }
 *               })
 *           ]
 *       })
 * ...
 *
 * @since 1.0.0
 * @extends {Route}
 */
class Router extends Route {
  static getGlobalRouter() {
    return historyController;
  }
  static getHistoryStack() {
    return history.slice();
  }

  static getLastHistory() {
    return history[history.length - 1];
  }

  static getHistoryByIndex(index) {
    return history[index];
  }
  /**
   * Factory method to create a new Router instance
   *
   * @param {RouterParams} props
   */
  static of(props = {}) {
    return new Router(props);
  }

  static createBlocker(fn) {
    return (router, path, routeData, action, doneFn) =&gt; {
      fn(path, routeData, action, ok =&gt; ok &amp;&amp; doneFn());
    };
  }

  /**
   * @constructor
   * @param {RouterParams} param
   */
  constructor({
    path = &quot;&quot;,
    build = null,
    routes = [],
    exact = false,
    sensitive = true,
    strict = true,
    isRoot = false,
    to = null,
    modal = false,
    routerDidEnter,
    routerDidExit,
    routeShouldMatch,
    homeRoute = null
  }) {
    super({ path, modal, build, routes, to, isRoot, routeShouldMatch });
    this._homeRoute = homeRoute;
    this._historyUnlisten = () =&gt; null;
    this._handlers = {
      routerDidEnter,
      routerDidExit
    };

    if (isRoot) {
      store = createStore();
      // this._store = createStore();
      /** @type {HistoryListener} */
      listeners.clear();
      historyController = createHistory({
        sensitive,
        strict,
        exact,
        path,
        getUserConfirmation: (blockerFn, callback) =&gt; {
          return blockerFn(callback);
        }
      });

      const pushHomes = path =&gt; {
        const matches = matchRoutes(store, [this].concat(this._routes), path);
        let len = 0;
        while (++len &lt; matches.length) {
          let route = matches[len].route;
          if (route.__is_router &amp;&amp; route.hasHome()) {
            route.pushHomeBefore &amp;&amp; route.pushHomeBefore(path);
          }
        }
      };

      this.initialize(
        historyController,
        (location, action, target, fromRouter = true) =&gt;
          this.onHistoryChange(location, action, target, fromRouter),
        pushHomes
        // pushIndexes.call(this, path)
      );
    }

    this._isRoot = isRoot;
    this._exact = exact;
    this._strict = strict;
    this._sensitive = sensitive;
    this._fromRouter = false;
  }

  /**
   * Router is initialized by parent
   *
   * @protected
   * @since 1.0.0
   * @param {HistoryListener} parentHistory
   * @param {function} onHistoryChange Root onHistoryChange handler
   * @param {function} pushHomes It uses in order to push routers&apos; home-route
   */
  initialize(parentHistory, onHistoryChange, pushHomes) {
    this._pushHomes = pushHomes;
    /** @type {HistoryController} */
    this._historyController = parentHistory.createNode(
      Object.assign({}, this._options, {
        getUserConfirmation: (blockerFn, callback) =&gt; {
          return blockerFn(callback);
        }
      })
    );

    this._routes.forEach(route =&gt; {
      route.initialize &amp;&amp;
        route.initialize(this._historyController, onHistoryChange, pushHomes);
    });

    this._unlisten = this._historyController.listen((location, action) =&gt; {
      onHistoryChange(location, action, this, true); // fires root&apos;s onHistoryChange
    });

    // changes route without history
    this.dispatch = (location, action, target, fromRouter = false) =&gt; {
      onHistoryChange(location, action, target, fromRouter);
    };
  }

  hasHome() {
    return this._homeRoute !== null;
  }

  /**
   * Fast router&apos;s instance checking
   *
   * @since 1.0.0
   * @return {boolean}
   */
  get __is_router() {
    return true;
  }

  /**
   * @ignore
   * @since 1.0.0
   */
  getHistory() {
    return this._historyController.history;
  }

  /**
   * Return current active url
   *
   * @since 1.0.0
   * @return {string}
   */
  getCurrentUrl() {
    return this._currentUrl;
  }

  /**
   * Adds eventlisteners to listen history changes
   * @example
   * const unlisten = router.listen((location, action) =&gt; {
   *     console.log(`new route location: ${location.pathname} action : ${action}`);
   * });
   *
   * @since 1.0.0
   * @param {HistoryListener} fn
   */
  listen(fn) {
    listeners.add(fn);

    return () =&gt; listeners.delete(fn);
  }

  /**
   * Adds route block handler to history. When history is changed in anywhere
   * then the handler intercepts before history is changed.
   * @example
   * var unload = router.addRouteBlocker((path, routeData, action, ok) =&gt; {
   * alert({
   *  message: &quot;Would you like to answer?&quot;,
   *  title: &quot;Question&quot;, //optional
   *  buttons: [{
   *  text: &quot;Yes&quot;,
   *      type: AlertView.Android.ButtonType.POSITIVE,
   *      onClick: function() {
   *        ok(true);
   *      }
   *    },
   *    {
   *      text: &quot;No&quot;,
   *      type: AlertView.Android.ButtonType.NEGATIVE,
   *      onClick: function() {
   *        ok(false);
   *      }
   *    }
   *  ]
   *  });
   * });
   *
   * @since 1.0.0
   * @param {RouterBlockHandler} fn
   */
  addRouteBlocker(fn) {
    Router.blocker = Router.createBlocker(fn);
    this._unblock = () =&gt; (Router.blocker = null);

    return this._unblock;
  }

  getStore() {
    return store;
  }

  /**
   * Handles history changes. Just Root router,
   * because routing flow mmust be always root to children,
   * in order to change display logic all the time.
   *
   * @since 1.0.0
   * @protected
   * @param {RouteLocation} location
   * @param {string} action
   * @param {Router} target Target Router which pushed to its router.
   * @param {boolean} [fromRouter=true]
   */
  onHistoryChange(location, action, target, fromRouter = true) {
    if (this._isRoot) {
      this._matches = matchRoutes(
        this.getStore(),
        [this].concat(this._routes),
        location.pathname
      );
      this.renderMatches(this._matches, location, action, target, fromRouter);
    }
  }

  /**
   * Removes last entry from history without trigger history is changed.
   *
   * @since 1.0.0
   * @ignore
   * @protected
   */
  routeRollback() {
    this._historyController.rollback();
  }

  /**
   * Renders route matches by requested path
   *
   * @protected
   * @since 1.0.0
   * @emits RouteShouldMatchHandler
   * @param {Array&lt;{isExact: boolean,params: object,path: string,url: string}&gt;} matches Route matches of the current request
   * @param {RouteLocation} location Current location
   * @param {string} action Current history action
   * @param {Router} target Target Router which pushed to its router.
   * @param {boolean} fromRouter If the specified request if from the router or an another source.
   */
  renderMatches(matches, location, action, target, fromRouter) {
    this._fromRouter = fromRouter;

    const routeData = location.state;

    matches.some(({ match, route }, index) =&gt; {
      route.setState({
        hash: location.hash,
        query: location.query,
        rawQuery: location.rawQuery,
        action,
        match
      });
      if (match.isExact !== true &amp;&amp; route !== this &amp;&amp; route.__is_router) {
        // if(index &gt; 0 &amp;&amp; this._isRoot)
        tasks.push((url, action) =&gt; {
          this.routeWillEnter &amp;&amp;
            this.routeWillEnter(route, url, action, false, target);
          // handleRouteUrl(this, url, routeData, action);
        }); // add new router display logic from root to children

        route.setUrl(location.pathname);

        // move routes to child router
        route.renderMatches(
          matches.slice(index, matches.length),
          location,
          action,
          target,
          fromRouter,
          this
        );

        return true;
      } else if (match.isExact === true) {
        const redirection = funcorVal(route.getRedirectto(), [this, route]);
        if (redirection &amp;&amp; redirection !== match.url) {
          tasks = []; // reset tasks
          target.routeRollback(); // remove redirected path from target Router
          //  because real path can be owned by different router.
          // -----
          // And then trigger redirection path.
          target.redirectRoute(route, routeData, action, target);
          return false;
        }

        const routingState =
          (route.getRoutingState &amp;&amp;
            route.getRoutingState(route._state, {
              match,
              action,
              routeData
            })) ||
          {};
        // change route state to move data to callbacks
        route.setState({
          query: location.search,
          match,
          action,
          routeData,
          routingState
        });
        route.setUrl(location.pathname);

        // If route owned by current child router which is different from target router
        // then push or pop route to child router&apos;s history.
        // Because current router isn&apos;t aware of the route.
        if (target != this) {
          handleRouteUrl(this, match.url, routeData, action);
        }

        // View operations must leave to end of rendering,
        // because there must not render any view before route blocking.
        // An another reason is we build views from child to parent but routing happens
        // parent to child.
        tasks.push(
          (url, action) =&gt;
            this.routeWillEnter &amp;&amp;
            this.routeWillEnter(route, url, action, true, target)
        );

        _lastRoute &amp;&amp; _lastRoute.routeDidExit(this);
        this.routeDidMatch(route); // fires routeDidMatch
        if (this._fromRouter) {
          const view = this.renderRoute(route); // build route&apos;s view
          route.setState({ view }); // keep view in the route&apos;s state
        }
        tasks.reverse().forEach(task =&gt; task(location.pathname, action)); // trigger all routers&apos; routeWillEnter in the tasks queue
        this.routerDidEnter &amp;&amp; this.routerDidEnter(route); // fires routerDidEnter
        route.routeDidEnter(this); // fires routeDidEnter
        _lastRoute = route; // save exact matched route as last route
        this._currentAction = action;
        this._prevRoute = route;
        dispatch(location, action);

        tasks = []; // clear tasks
        return true;
      }
    });

    this._fromRouter = false;

    return true;
  }

  /**
   * Handles a new route activated in the router
   *
   * @since 1.0.0
   * @event
   * @protected
   * @param {Route} route
   */
  routerWillEnter(route) {}

  /**
   * @since 1.0.0
   * @ignore
   * @param {string} url
   * @param {string} action
   */
  isUrlCurrent(url, action) {
    const res = this._currentUrl === url &amp;&amp; this._currentAction === action;
    return res;
  }

  /**
   * Life-cycle event handler handles when Router is activated
   * @example
   * ....
   * Router.of({
   *  routerDidEnter: (router, route) =&gt; {
   *    ...
   *  }
   * })
   *
   * @since 1.0.0
   * @emits routerDidEnter
   * @protected
   * @param {Route} route
   */
  routerDidEnter(route) {
    this._handlers.routerDidEnter &amp;&amp; this._handlers.routerDidEnter(this, route);
  }

  /**
   * Sets the router statically as active router
   *
   * @since 1.0.0
   * @protected
   * @param {string} action
   */
  setasActiveRouter(action) {
    Router.currentRouter &amp;&amp;
      this != Router.currentRouter &amp;&amp;
      Router.currentRouter.routerDidExit &amp;&amp;
      Router.currentRouter.routerDidExit(action);
    Router.currentRouter = this;
  }

  /**
   * Handles router is deactivated.
   *
   * @since 1.0.0
   * @example
   * ....
   * Router.of({
   *  routerDidExit: (router, action) =&gt; {
   *    ...
   *  }
   * })
   *
   * ...
   * @emits routerDidExit
   * @param {string} action
   */
  routerDidExit(action) {
    this._handlers.routerDidExit &amp;&amp; this._handlers.routerDidExit(this, action);
  }

  /**
   * Redirects route and removes last route record from history.
   *
   * @protected
   * @param {Route} route
   * @param {object} routeData
   * @param {string} action
   */
  redirectRoute(route, routeData, action) {
    // redirection of a route
    this.push(funcorVal(route.getRedirectto(), [this, route]), routeData); // and add new route
    // this._historyController.push(route.getRedirectto(), routeData);
  }

  /**
   * @since 1.0.0
   * @private
   * @ignore
   * @param {Page} view
   */
  isViewEmpty(view) {
    return view !== null || view !== undefined;
  }

  /**
   * Route is matched handler.
   *
   * @since 1.0.0
   * @protected
   * @param {Route} route
   */
  routeDidMatch(route) {
    const { match, action, routeData } = route.getState();
    if (match.isExact) {
      const prevUrl = this._currentUrl;
      this.setasActiveRouter(action);
    }
  }

  /**
   * Render route
   *
   * @since 1.0.0
   * @protected
   * @param {Route} route
   * @throws {TypeError}
   */
  renderRoute(route) {
    const view = route.build &amp;&amp; route.build(this);
    if (!view) throw new TypeError(`${route} &apos;s View cannot be empty!`);

    return view;
  }

  /**
   * Helper method that pushes the route&apos;s url to history
   *
   * @since 1.0.0
   * @protected
   * @param {Route} route
   */
  pushRoute(route) {
    if (!(route instanceof Route))
      throw new TypeError(`route must be instance of Route`);
    this.push(
      funcorVal(route.getRedirectto(), [this, route]) || route.getUrlPath()
    );
  }

  /**
   * Change history by specified path
   *
   * @since 1.0.0
   * @param {object|string} path - Path or matches of the route
   * @param {!object} [routeData={}] routeData - Routing data
   * @return {Router}
   */
  push(path, routeData = {}) {
    if (path === this._state.url) {
      Object.assign(this._historyController.history.location.state, {
        routeData
      });
      this.dispatch(
        this._historyController.history.location,
        &quot;PUSH&quot;,
        this,
        true
      );

      return this;
    }

    this._fromRouter = true;
    // if (!this.isValidPath(path)) throw new TypeError(`[${path}] Pat h is invalid`);
    if (path.charAt(0) !== &quot;/&quot;) {
      path = this._path.getPath() + &quot;/&quot; + path;
    }

    if (Router.blocker) {
      Router.blocker(this, path, routeData, &quot;PUSH&quot;, () =&gt;
        this._historyController.push(path, routeData)
      );

      return this;
    }
    try {
      this._pushHomes(path);
    } catch (e) {
      throw e;
    }
    this._historyController.push(path, routeData);
    this._fromRouter = false;
    return this;
  }

  isValidPath(path) {
    return /^(\/\w+)+(\.)?\w+(\?(\w+=[\w\d]+(&amp;\w+=[\w\d]+)*)+){0,1}$/.test(
      path
    );
  }

  /**
   * Replaces specified path&apos;s state
   *
   * @since 1.0.0
   * @ignore
   * @param {string} path
   * @param {data} routeData
   */
  replace(path, routeData) {
    this._historyController.history.replace(path, routeData);
  }

  /**
   * Rewinds the history
   *
   * @since 1.0.0
   * @param {string | RouteLocation} url This routes an experimental feature. If you use this feature you should use for same StackRouter stack.
   * @return {Router}
   */
  goBack(url) {
    const go = () =&gt; {
      this._fromRouter = true;

      url
        ? this.dispatch(
            typeof url === &quot;string&quot;
              ? { pathname: url, hash: &quot;&quot;, search: &quot;&quot;, state: {} }
              : url,
            &quot;POP&quot;,
            this,
            true
          )
        : this._historyController.goBack();
      this._fromRouter = false;
    };
    if (Router.blocker) {
      Router.blocker(this, null, null, &quot;POP&quot;, () =&gt; go());

      return this;
    }

    go();
  }

  /**
   * Returns last location of history
   *
   * @since 1.0.0
   * @return {RouteLocation}
   */
  getLocation() {
    return this._historyController.history.location;
  }

  /**
   * Returns History entries as Array
   *
   * @since 1.0.0
   * @return {Array&lt;string&gt;}
   */
  getHistoryasArray() {
    return this._historyController.getHistoryasArray();
  }

  /**
   * Forwards history
   *
   * @experimental
   * @ignore
   * @since 1.0.0
   */
  goForward() {
    this._historyController.history.goForward();
  }

  /**
   * Changes route by history index.
   *
   * @experimental
   * @since 1.0.0
   * @ignore
   * @param {number} index
   */
  go(index) {
    this._historyController.go(index);
  }

  /**
   * Adds new route
   *
   * @since 1.0.0
   * @ignore
   * @experimental
   * @param {Route} route
   */
  add(route) {
    this._routes.push(route);
  }

  /**
   * Iterates child routes
   *
   * @since 1.0.0
   * @param {function} fn
   * @return {Array}
   */
  map(fn) {
    return this._routes.map(fn);
  }

  /**
   * Unloads the router
   * @since 1.0.0
   */
  dispose() {
    this._historyUnlisten();
    // if (this._isRoot) {
    this._historyController.dispose();
    this._historyController = null;
    // }
    this._routes.forEach(route =&gt; route.dispose());
    this._routes = null;
    this._historyUnlisten = null;
    this._unblock &amp;&amp; this._unblock();
    this._unblock = null;
    this._handlers = null;
    this._unlisten &amp;&amp; this._unlisten();
    this._listen = null;
  }
}

module.exports = Router;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
